---
title: "03-02-visualization"
author: "Dr. Jeff Jacob"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Chapter 3: Data Visualization

In this unit, we recreate and extend the figures from Chapter 3 using the **ggplot ecosystem**.

The goal is not just to reproduce charts, but to understand:

-   *why* a specific chart is appropriate,
-   *what patterns* it reveals,
-   and *how visualization supports modeling decisions later*.

------------------------------------------------------------------------

## Load required packages

```{r}
#| echo: FALSE
#| output: FALSE
library(tidyverse)
library(ggthemes)
library(patchwork)
library(caret)
library(GGally)
library(ggcorrplot)
library(skimr)
library(mlbadata)
```

------------------------------------------------------------------------

## Load datasets

```{r, echo = FALSE}

mpg.df <- as_tibble(mpg)
housing.df <- as_tibble(mlbadata::BostonHousing)
bank.df <- as_tibble(mlbadata::UniversalBank)
utilities.df <- as_tibble(mlbadata::Utilities)

```

------------------------------------------------------------------------

## 1. Univariate data- density and bar plots

### x-var is continuous

### Histogram

```{r}
g1 <- mpg.df |> 
  ggplot(aes(x = hwy)) +
  geom_histogram(binwidth = 4)
g1
```

### Frequency Polygon

Frequency polygon is another visual to capture distribution. It creates histrograms and then uses a line to join the mid-points of the bins.

```{r}
mpg.df |> 
  ggplot(aes(x = hwy)) +
  geom_freqpoly(binwidth = 4)
```

Works better if we want to compare across different categorical variables.

```{r}
mpg.df |> 
  ggplot(aes(x = hwy, color = drv)) +
  geom_freqpoly(binwidth = 4)
```

### Density Plot

If we want to obtain a density curve, we can use the `geom_density()` function.

```{r}
mpg.df |> 
  ggplot(aes(x = hwy)) +
  geom_density() +
  labs(title = "Distribution of Highway MPG")


```

> **Interpretation tip:** Histograms/frequency polygons emphasize *counts*; densities emphasize *shape*.

### x-var is discrete.

A bar chart shows the count.

```{r}
g2 <- mpg.df |> 
  ggplot(aes(x = class)) +
  geom_bar() +
  labs(title = "Number of Cars by Class")

g2
```

## Bivariate Plots

A scatter chart with colors based on a categorical variables:

```{r}
g3 <- mpg.df |> 
  ggplot(aes(x = cyl, y = hwy)) +
  geom_point() +
  labs(title = "Highway MPG vs Cylinders")

g3
```

The above looks strange as a lot of points are getting overlaid on top of each other. This can be fixed by assigning some randomness to the values. Let us also add color for `drv`.

```{r}
g3 <- mpg.df |> 
  ggplot(aes(x = cyl, y = hwy, color = drv)) +
  geom_jitter() +
  labs(title = "Highway MPG vs Cylinders")

g3
```

Jittering helps reduce overplotting when many points share the same value.

------------------------------------------------------------------------

### Student exercise: alternative plots

```{r}
#| eval: false
# Create:
# 1. A bar chart of drv
# 2. A density plot of cty
```

------------------------------------------------------------------------

## Combining plots

Multiple plots can be combined using `patchwork`.

```{r}
library(patchwork)

(g1 + g2) / g3
```

This is useful for dashboards and comparative storytelling.

------------------------------------------------------------------------

------------------------------------------------------------------------

## 2. Cross-Sectional Visualization

Cross-sectional plots help us compare groups and distributions at a single point in time.

------------------------------------------------------------------------

### Bar plots for categorical comparisons

```{r}
housing.df |>
  group_by(CHAS, CAT.MEDV) |> 
  summarise(count = n())

housing.df |>
  mutate(across(c(CHAS, CAT.MEDV), as.factor)) |> 
  group_by(CHAS, CAT.MEDV) |> 
  summarise(count = n())
```

Here, we have two factor variables. Suppose we want to see a bar chart representing the count of neighborhoods bordering and not bordering Charles River with median home values being above or below a threshold (below = 0 or above = 1)

```{r}
housing.df |>
  mutate(across(c(CHAS, CAT.MEDV), as.factor)) |> 
  ggplot(aes(CHAS, fill= CAT.MEDV)) +
  geom_bar()



```

This is a stacked bar chart. The default aesthetic is "stack"

-   stacked bars → composition Try:

-   filled bars → proportions

-   dodged bars → comparison

```{r}

housing.df |>
  mutate(across(c(CHAS, CAT.MEDV), as.factor)) |> 
  ggplot(aes(CHAS, fill= CAT.MEDV)) +
  geom_bar(position = "fill")


```

```{r}

housing.df |>
  mutate(across(c(CHAS, CAT.MEDV), as.factor)) |> 
  ggplot(aes(CHAS, fill= CAT.MEDV)) +
  geom_bar(position = "dodge")


```

------------------------------------------------------------------------

### Density vs histogram

```{r}
s1 <- housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_density(aes(fill = factor(CHAS)), alpha = 0.3)

s2 <- housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_histogram(aes(fill = factor(CHAS)), alpha = 0.3)
```

```{r}
s1 / s2
```

### Combining density and histogram correctly

Suppose we want to combine the density plot and the histogram in the same chart. The first thought is to add them as layers.

```{r}
housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_histogram(aes(fill = factor(CHAS)), alpha = 0.3) +
  geom_density(aes(fill = factor(CHAS)), alpha = 0.3)
```

The density plot comes as a flat line. Why? Because of the difference in scales.

Instead, we can tell ggplot that the histogram y axis should be scaled to density. Then the histogram and density will have the same scale.

```{r}
housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_histogram(aes(fill = factor(CHAS), y = after_stat(density)), alpha = 0.25) +
  geom_density(aes(color = factor(CHAS)), size = 1) 
```

*We didn't have to modify the aesthetics of density as it was already scaled correctly.*

### Box plots

X $\rightarrow$ discrete & Y $\rightarrow$ continuous

```{r}
housing.df |> 
  ggplot(aes(y = MEDV, x = factor(CHAS))) +
  geom_boxplot() +
  labs(title = "MEDV Distribution by CHAS")
```

Box plots quickly reveal:

-   median shifts
-   spread
-   outliers

------------------------------------------------------------------------

## 3. Multivariate Visualization

### Correlation heatmaps

```{r}
cormat <- data.frame(round(cor(housing.df), 2))
cormat$xvar <- rownames(cormat)

cor.tidy <- cormat |> 
  pivot_longer(!xvar, names_to = "yvar", values_to = "corrval")
```

```{r}
cor.tidy |> 
  ggplot(aes(x = xvar, y = yvar, fill = corrval)) +
  geom_tile(color = "white") +
  geom_text(aes(label = corrval), size = 3) +
  theme(axis.text.x = element_text(angle = 90))
```

> **Why this matters:** Correlation plots guide feature selection and multicollinearity checks.

------------------------------------------------------------------------

### Scatter plots with transformations

```{r}
gg7 <- housing.df |> 
  ggplot(aes(x = CRIM, y = MEDV)) +
  geom_point()

gg8 <- housing.df |> 
  ggplot(aes(x = CRIM, y = MEDV)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
```

```{r}
gg7 + gg8
```

------------------------------------------------------------------------

### Labeling points

```{r}
utilities.df |> 
  ggplot(aes(x = Sales, y = Fuel_Cost, label = Company)) +
  geom_point() +
  geom_text(nudge_x = 0.02, size = 2)
```

------------------------------------------------------------------------

### Overplotting and jitter

```{r}
bank.df |> 
  ggplot(aes(x = Income, y = CCAvg)) +
  geom_point()

bank.df |> 
  ggplot(aes(x = Income, y = CCAvg,
             color = factor(Securities.Account))) +
  geom_jitter(alpha = 0.5) +
  scale_x_log10() +
  scale_y_log10()
```

------------------------------------------------------------------------

### Parallel coordinate plots

```{r}
housing.df |>
  mutate(CAT.MEDV = factor(CAT.MEDV)) |> 
  ggparcoord(columns = 1:13,
             groupColumn = 14,
             scale = "uniminmax")
```

------------------------------------------------------------------------


## Key takeaways

-   Visualization is **analysis**, not decoration

-   Different plots answer different questions

-   Visuals guide:

    -   feature engineering
    -   transformations
    -   model choice

-   Always ask: *What decision does this plot support?*
