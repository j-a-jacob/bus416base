---
title: "11-01-intro_r_py"
format: html
editor: visual
author: Dr. Jeff Jacob
---

##Python or R? Why not Both?

### Welcome to the reticulate library.

Reticulated python is the world's longest species of snake. reticulate is the package which brings in python in R, thus extending the reach of both languages. What is great about posit is that once the python environment is correctly set-up, we can use it within the R code chunk ('R'eticulated python). What is even more special is that we can use python natively as well!



``` {r}
library(reticulate)
library(mlbadata)
library(tidyverse)
library(caret)
library(nnet)
library(fastDummies)
```


```  {r}       
# A virtual python environment has already been setup. We activate it here
use_virtualenv("mlpyenv")
```

First to use python natively:



```{python}         
4 + 5
```

```{python}         
print("Hello world! This is python")
```

```{python}        
2**3
```

```{python}        
#| eval: false
# Exercise:
# Compute 7 squared.
# Then compute 2 raised to the power of 5.
```

```{python}         
fruits = ["apples", "grapes", "oranges", "melons"]

j = "cheese"
for i in fruits:
  print(f"I like {i}. But I like {j} also.")
```

```{python}         
#| eval: false
# Exercise:
# Add one more fruit to the list.
# Change j to a different food.
# Print the updated output using the same loop.
```

### Initial Greetings between R and Python

# `R` environment:

```{r}         
text <- "Hello there from R"
print(text)
```

# `Python` environment:

```{python}         
text = "Hello there from Python"
print(text)
```


# `R` and `Python` talking to each other:

```{python}         
# Getting python to hear from R
print(r.text)
```

```{r}         
# Now R's turn to listen to python
print(py$text)
```

```         
#| eval: false
# Exercise:
# Create a new object in R.
# Access it from Python using r.<object>.
```

### Working with lists

Let's make numeric lists natively in Python.

```{python}         
a = list(range(1,101))
print(a)
min(a)
max(a)
```

```{python}         
#| eval: false
# Exercise:
# Create a list from 1 to 50.
# Print its minimum and maximum values.
```

Let's say we want to add 10 to each element in the list.

```{python}          
b = []

for i in a:
  b.append(i + 10)

print(b)
```

```{python}         
#| eval: false
# Exercise:
# Create a new empty list.
# Use a loop to multiply each element of a by 2.
# Print the result.
```

This makes working with numerical data slow in python.

We can aslo import the object a into R and carry out the above calculation. To access python objects in R, we will use the accessor: py\$

``` {r}        
b_r = py$a + 10
b_r
```

```{r}         
#| eval: false
# Exercise:
# Add 25 to the Python list a using R.
# Store the result in a new R object.
```

We can also bring in b_r into python using the . operator: r.

```{python}          
max(r.b_r)
sum(r.b_r)
```

```{python}          
#| eval: false
# Exercise:
# Compute the minimum value of r.b_r in Python.
```

This is just scratching the surface. But, as we can see, we can work with R and python in a harmonious way and even call other software's objects into their own environment.

Brief on Numerical Python

While, we can not work in a vectorised manner in native python, we can also use an extremely powerful package, numpy for this. numpy is a core package at the heart of machine learning in python which converts lists into arrays and allows for vectorised operations in Python. Let us, very briefly, look at the workings of numpy

```{python}          
import numpy as np
```

The default object on numpy is an n- dimensional array (a grid of values). The rank of an array is the number of dimension while the shape is a tuple giving the number of elements along each dimension.

```{python}          
a1 = np.array([3, 5, 7, 9])
print(a1)
np.ndim(a1)
```

```{python}          
a1.ndim
```

```{python}          
#| eval: false
# Exercise:
# Create a numpy array with five numbers.
# Check its number of dimensions.
```

Why does a1.ndim work? a1 is an object of the ndarray class and thus inherits all the methods.

``` {python}         
type(a1)
```

To see the shape:

``` {python}         
a1.shape
```

```{python}          
#| eval: false
# Exercise:
# Create a new numpy array with three elements.
# Print its shape.
```

It is a vector with 4 rows. numpy broadcasts objects like R

```{python}          
a1 + 10
```

``` {python}         
np.arange(1,101) + 10
```

```{python}          
#| eval: false
# Exercise:
# Use np.arange to create numbers from 1 to 20.
# Add 5 to each element.
```

np.arange(start, stop, step) is generally used to create 1d arrays. We can also create equally spaced arrays using np.linspace(start, stop, number)

```{python}          
np.linspace(0,10,5)
np.linspace(0,10,5).dtype
```

``` {python}         
#| eval: false
# Exercise:
# Create 4 equally spaced values between 0 and 8.
# Check the data type.
```

In machine learning, we mainly work with tabular data (2 dimensions).

``` {python}         
a2 = np.array(
  [[2, 5, 6], 
  [10 , 3, 12], 
  [2, 6, 1], 
  [3, 1, 7]])
```

```{python}          
print(a2)
a2.ndim
a2.shape
```

```{python}          
#| eval: false
# Exercise:
# Index the element in the second row and third column of a2.
```

3d arrays:

```{python}          
a3 = np.array([[[1, 3, 4], [23, 12, 3], [1, 4, 5]],
[[2, 4, 1], [34, 12, 9],[4, 1, 7]]])
```

``` {python}         
print(a3)
a3.ndim
a3.shape
```

``` {python}         
#| eval: false
# Exercise:
# Access the first element of the first row in the first layer.
```

Reshaping arrays

```{python}          
p1 = np.random.randint(0, 256, 100)
p1.shape
```

```{python}          
p2 = np.random.randint(0, 256, 100).reshape((10,10))
p2.shape
print(p2)
```

``` {python}         
p3 = p2/255
print(p3)
```

```{python}          
#| eval: false
# Exercise:
# Confirm the maximum value of p3 is less than or equal to 1.
```

``` {python}         
p4 = p3.reshape(100,1)
p4.shape
p4[0:5]
```

```{python}          
#| eval: false
# Exercise:
# Reshape p3 into a (50, 2) array.
# Check the shape.
```

Reshaping back

```{python}          
p5 = p4.reshape(10,10)
p5.shape
p5[0, 0:5]
```

numpy within R

``` {r}         
np <- import("numpy", convert = FALSE)
np1 <- import("numpy", convert = TRUE)
```

```{r}         
x <- np1$arange(1, 9)
x
```

```{r}         
x <- np$arange(1, 9)
x
```

``` {r}        
#| eval: false
# Exercise:
# Use numpy from R to create values from 1 to 20.
```

```{r}         
p6 <- np$random$randint(0, 255, 100L)
p6
```

```{r}         
p7 <- p6$reshape(10L, 10L)
p7/255
```

```{r}         
#| eval: false
# Exercise:
# Normalize p7 so all values are between 0 and 1.
```

__In the above code, `10L` means the integer 10. Otherwise, if we just type 10, python will read it as 10. (a float) and throw an error.__


